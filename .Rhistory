df_cats[] <- lapply(df_cats, as.factor)
# Entropías
H  <- sapply(df_cats, entropy)
K  <- sapply(df_cats, function(f) length(levels(f)))
Hn <- H / log2(K)  # 0..1
round(rbind(H, Hn), 3)
barplot(Hn, ylim = c(0,1), col = "steelblue",
main = "Entropía normalizada por método",
ylab = "Entropía (0–1)")
abline(h = seq(0,1,0.2), col = "gray90")
# 0) Cartel original (orden de salida al escenario)
lineup <- c("Alpha", "Blaze", "Comet", "Dynamo", "Echo", "Flux")
n <- length(lineup)
seq_len(n)  # índices 1..n
# 1) Dirección del festival reordena todo (por criterios aleatorios)
p <- perm_random(n)   # p es una permutación de 1..n
p; is_permutation(p); perm_check(p)  # validación
# Aplicamos la reordenación al cartel:
lineup_new <- perm_apply(lineup, p)
cbind(Original = lineup, "Nueva orden" = lineup_new)
# 2) Arrepentimiento de última hora: "deshaz lo anterior"
#    Para revertir un reordenamiento lineup_new <- lineup[p],
#    basta aplicar la inversa q = perm_invert(p): lineup_new[q] == lineup
q <- perm_invert(p)
all(lineup == perm_apply(lineup_new, q))  # TRUE
# 3) Incidencia técnica: intercambiamos posiciones 2 y 5 sobre la identidad
swap_2_5 <- perm_swap_n(n, 2, 5)  # transposición elemental
swap_2_5
# 4) Cambio compuesto "primero el aleatorio p y luego el swap (2,5)"
#    r = swap ∘ p  =>  r[i] = swap[p[i]]
r <- perm_compose(swap_2_5, p)
lineup_final <- perm_apply(lineup, r)
cbind(Original = lineup, "Final" = lineup_final)
# 5) Paridad de la permutación final (nº de inversiones)
perm_parity(r)  # "even"/"odd" y signo
# 6) Descomposición en ciclos para entender "quién reemplaza a quién"
perm_cycles(r)
# 7) Matriz de permutación: reordenar por álgebra lineal
P <- perm_matrix(r)
# Demostramos equivalencia: P %*% x == x[r]
x <- seq_len(n)                   # vector numérico de ejemplo
y_index <- perm_apply(x, r)
y_mat   <- as.vector(P %*% x)
identical(y_index, y_mat)         # TRUE
# 8) Arreglo fino: ¿y si solo queremos corregir un par de posiciones en la final?
#    Supón que te piden "intercambia lo que quedó en las posiciones 3 y 6"
r2 <- perm_swap_p(r, 3, 6)
lineup_fine <- perm_apply(lineup, r2)
cbind("Final (antes)" = lineup_final, "Final (corregido)" = lineup_fine)
# 9) Qué NO es una permutación (demo de control de errores)
bad_p <- c(1,2,2,4,5,6)
try(perm_check(bad_p))  # lanza error claro
![Carrera de drones](images/drones.jpg){width=70%}
knitr::include_graphics("images/drones.jpg")
```{r, echo=FALSE, include=FALSE}
## ---------------------------
## Basics · Carrera de drones
## ---------------------------
set.seed(123)
files <- c("objects", "io", "Permutation", "utils")
lapply(files, function(f) source(paste0("R/", f, ".R")))
n          <- length(checkpoints)    # 51
# 2) Estado inicial de baterías (100% en todos los puntos)
battery <- rep(100, n)   # repite 100, n veces
pos_labels <- paste0("Pos", 1:n)
speed_kmh <- 30 + 5*sin(checkpoints/10) + rnorm(n, 0, 1.2)
cheers_db <- 200 + 800*abs(cos(checkpoints/12)) + rnorm(n, 0, 25)
# Ponemos nombres a los elementos para trazabilidad
names(speed_kmh) <- names(cheers_db) <- pos_labels
Consultas típicas. Un ejemplo: ¿qué velocidad llevamos exactamente en los bonus pit-stops (múltiplos de 7 km)?
```{r, fig.width=10, fig.height=6, out.width="100%"}
# 6) Consultas típicas con lógicas:
#    - ¿en qué puntos tenemos bonus y qué velocidad llevamos ahí?
i_bonus <- checkpoints %% 7 == 0
data.frame(
checkpoint_km = checkpoints[i_bonus],
speed_bonus   = round(speed_kmh[i_bonus], 2)
)
# 7) Normalización y estandarización
#    - Normalizamos cheering a [0,1] para compararlo con otras señales
#    - Estandarizamos la velocidad para comparar "desviaciones" (z-scores)
cheers_norm <- normalize01(cheers_db)
speed_z     <- standardize(speed_kmh)
# 8) Propiedades esperadas (comprobaciones rápidas)
range(cheers_norm)            # ~ 0..1
round(mean(speed_z), 6)       # ~ 0
round(sd(speed_z), 6)         # ~ 1
# 9) Mini tabla de resumen (primeras filas)
head(
data.frame(
pos         = pos_labels,
km          = checkpoints,
speed_kmh   = round(speed_kmh, 2),
speed_z     = round(speed_z, 2),
cheers_db   = round(cheers_db, 1),
cheers_norm = round(cheers_norm, 3),
bonus       = ifelse(i_bonus, "sí", "no")
),
8
)
library(ggplot2)
speed_z_norm01 <- normalize01(speed_z)
png("grafico.png")
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
lines(checkpoints, speed_z_norm01, lwd = 2, lty = 2)
length(checkpoints)
length(cheers_norm)
length(speed_z_norm01)
png("grafico.png", width=800, height=600)
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
lines(checkpoints, speed_z_norm01, lwd = 2, lty = 2)
legend("topright",
legend = c("cheers_norm", "normalize01(speed_z)"),
lwd = 2, lty = c(1,2), bty = "n")
plot.new()
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
lines(checkpoints, speed_z_norm01, lwd = 2, lty = 2)
legend("topright",
legend = c("cheers_norm", "normalize01(speed_z)"),
lwd = 2, lty = c(1,2), bty = "n")
plot(checkpoints, cheers_norm, type="l")
lines(checkpoints, speed_z_norm01, lty=2)
plot(checkpoints, cheers_norm, type="l")
lines(checkpoints, speed_z_norm01, lty=2)
plot.new()
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
lines(checkpoints, speed_z_norm01, lwd = 2, lty = 2)
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
lines(checkpoints, speed_z_norm01, lwd = 2, lty = 2)
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
legend("topright",
legend = c("cheers_norm", "normalize01(speed_z)"),
lwd = 2, lty = c(1,2), bty = "n")
plot(checkpoints, cheers_norm, type = "l", lwd = 2,
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada")
# Equal Width (4 bins)
res_ew <- discretizeEW(speed_kmh, num.bins = 4)
# Equal Frequency (4 bins)
res_ef <- discretizeEF(speed_kmh, num.bins = 4)
# Cortes manuales (ejemplo): lento < 28, crucero [28,32], rápido (32,35], turbo > 35
cuts_manual <- c(28, 32, 35)
res_manual  <- discretize(speed_kmh, cut.points = cuts_manual)
# Vista rápida de categorías (primeras 8)
head(data.frame(
km      = checkpoints,
v_kmh   = round(speed_kmh, 2),
EW      = res_ew$categorias,
EF      = res_ef$categorias,
Manual  = res_manual
), 8)
tab_ew <- table(res_ew$categorias)
tab_ef <- table(res_ef$categorias)
tab_mn <- table(res_manual)
# Unificamos categorías (por si etiquetas difieren en texto)
all_cats <- sort(unique(c(names(tab_ew), names(tab_ef), names(tab_mn))))
# Construimos matriz de conteos
counts <- rbind(
EW     = as.numeric(tab_ew[all_cats]),
EF     = as.numeric(tab_ef[all_cats]),
Manual = as.numeric(tab_mn[all_cats])
)
# Reemplazar NA por 0
counts[is.na(counts)] <- 0
# Colocar nombres de columnas
colnames(counts) <- all_cats
# Barplot apilado por método
op <- par(mar = c(9, 4, 3, 1))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
legend.text = rownames(counts),
args.legend = list(x = "topright", bty = "n"))
par(op)
mis_colores <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728")
op <- par(mar = c(9, 4, 3, 1))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores,
legend.text = rownames(counts),
args.legend = list(x = "topright", bty = "n"))
op <- par(mar = c(9, 4, 3, 1))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores)
legend("topright", inset = c(-0.25, 0),      # mueve la leyenda fuera
legend = rownames(counts),
fill = mis_colores, bty = "n")
matplot(checkpoints,
cbind(cheers_norm, speed_z_norm01),  # dos columnas → dos líneas
type = "l", lwd = 2, lty = c(1, 2),
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada",
col = c("black", "black"))  # mismo color, distinto lty
matplot(checkpoints,
cbind(cheers_norm, speed_z_norm01),  # dos columnas → dos líneas
type = "l", lwd = 2, lty = c(1, 2),
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada",
col = c("black", "black"))  # mismo color, distinto lty
legend("topright",
legend = c("cheers_norm", "normalize01(speed_z)"),
lwd = 2, lty = c(1,2), bty = "n")
matplot(checkpoints,
cbind(cheers_norm, speed_z_norm01),  # dos columnas → dos líneas
type = "l", lwd = 2, lty = c(1, 2),
xlab = "Kilómetro", ylab = "Escala [0,1]",
main = "Cheering normalizado vs. velocidad (z) re-escalada",
col = c("black", "black"))  # mismo color, distinto lty
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores,
legend.text = rownames(counts),
args.legend = list(x = "topright", bty = "n"))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores,
legend.text = rownames(counts),
args.legend = list(x = "topright", inset = c(-0.15, 0), bty = "n"))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores,
legend.text = rownames(counts),
args.legend = list(x = "topright", inset = c(-0.1, 0), bty = "n"))
barplot(t(counts), beside = TRUE, las = 2,
main = "Comparativa de conteos por categoría",
ylab = "Nº observaciones",
col = mis_colores,
legend.text = rownames(counts),
args.legend = list(x = "topright", inset = c(-0.07, 0), bty = "n"))
```{r}
df_cats <- data.frame(
EW     = res_ew$categorias,
EF     = res_ef$categororias <- res_ef$categorias,  # asegurar factor
Manual = res_manual
)
# Aseguramos tipo factor en todas las columnas
df_cats[] <- lapply(df_cats, as.factor)
# Entropías
H  <- sapply(df_cats, entropy)
K  <- sapply(df_cats, function(f) length(levels(f)))
Hn <- H / log2(K)  # 0..1
round(rbind(H, Hn), 3)
barplot(Hn, ylim = c(0,1), col = "steelblue",
main = "Entropía normalizada por método",
ylab = "Entropía (0–1)")
abline(h = seq(0,1,0.2), col = "gray90")
bp <- barplot(Hn,
ylim = c(0, 1),
col = mis_colores,
main = "Entropía normalizada por método",
ylab = "Entropía (0–1)")
abline(h = seq(0, 1, 0.2), col = "gray70", lty = "dashed")
bp <- barplot(Hn,
ylim = c(0, 1),
col = mis_colores,
main = "Entropía normalizada por método",
ylab = "Entropía (0–1)")
## ---------------------------
## Permutaciones · Mini-festival
## ---------------------------
set.seed(99)
# 0) Cartel original (orden de salida al escenario)
lineup <- c("Alpha", "Blaze", "Comet", "Dynamo", "Echo", "Flux")
n <- length(lineup)
seq_len(n)  # índices 1..n
# 1) Dirección del festival reordena todo (por criterios aleatorios)
p <- perm_random(n)   # p es una permutación de 1..n
p; is_permutation(p); perm_check(p)  # validación
# Aplicamos la reordenación al cartel:
lineup_new <- perm_apply(lineup, p)
cbind(Original = lineup, "Nueva orden" = lineup_new)
# 2) Arrepentimiento de última hora: "deshaz lo anterior"
#    Para revertir un reordenamiento lineup_new <- lineup[p],
#    basta aplicar la inversa q = perm_invert(p): lineup_new[q] == lineup
q <- perm_invert(p)
all(lineup == perm_apply(lineup_new, q))  # TRUE
# 3) Incidencia técnica: intercambiamos posiciones 2 y 5 sobre la identidad
swap_2_5 <- perm_swap_n(n, 2, 5)  # transposición elemental
swap_2_5
# 4) Cambio compuesto "primero el aleatorio p y luego el swap (2,5)"
#    r = swap ∘ p  =>  r[i] = swap[p[i]]
r <- perm_compose(swap_2_5, p)
lineup_final <- perm_apply(lineup, r)
cbind(Original = lineup, "Final" = lineup_final)
# 5) Paridad de la permutación final (nº de inversiones)
perm_parity(r)  # "even"/"odd" y signo
# 6) Descomposición en ciclos para entender "quién reemplaza a quién"
perm_cycles(r)
# 7) Matriz de permutación: reordenar por álgebra lineal
P <- perm_matrix(r)
# Demostramos equivalencia: P %*% x == x[r]
x <- seq_len(n)                   # vector numérico de ejemplo
y_index <- perm_apply(x, r)
y_mat   <- as.vector(P %*% x)
identical(y_index, y_mat)         # TRUE
# 8) Arreglo fino: ¿y si solo queremos corregir un par de posiciones en la final?
#    Supón que te piden "intercambia lo que quedó en las posiciones 3 y 6"
r2 <- perm_swap_p(r, 3, 6)
lineup_fine <- perm_apply(lineup, r2)
cbind("Final (antes)" = lineup_final, "Final (corregido)" = lineup_fine)
# 9) Qué NO es una permutación (demo de control de errores)
bad_p <- c(1,2,2,4,5,6)
try(perm_check(bad_p))  # lanza error claro
# (A) Simulamos y guardamos un CSV auto-contenido (para la demo de lectura)
bands <- data.frame(
band        = c("Alpha","Blaze","Comet","Dynamo","Echo","Flux"),
set_minutes = c(40, 35, 50, 45, 30, 55),          # continuo (entero)
bpm_mean    = c(128, 140, 110, 150, 95, 132),     # continuo (entero)
energy      = c(7.5, 8.8, 6.1, 9.2, 5.5, 7.9),    # continuo (num)
db_peak     = c(98, 103, 95, 106, 92, 101),       # continuo (entero)
genre       = c("EDM","Rock","Indie","Metal","Acoustic","EDM"), # categórico
stage       = c("A","B","A","B","A","B"),         # categórico
slot        = c("Early","Mid","Mid","Late","Early","Late"),     # categórico
stringsAsFactors = FALSE
)
tmp_csv <- tempfile(fileext = ".csv")
write.csv(bands, tmp_csv, row.names = FALSE)
# (B) Abrimos un log y anotamos los pasos
logf <- tempfile(fileext = ".log")
con  <- log_open(logf)
log_write(con, sprintf("Guardado CSV simulado en: %s", tmp_csv))
# (C) Leemos con tipado automático
df <- read_typed_csv(tmp_csv, max_levels = 6)
log_write(con, "CSV leído con read_typed_csv() y tipado automático")
# Revisamos tipos detectados
str(df)
# Cerramos y mostramos el log
log_write(con, "Fin de la etapa IO+Logging")
log_close(con)
tail(readLines(logf), 3)
# Seleccionamos solo las columnas numéricas
num_cols <- c("set_minutes","bpm_mean","energy","db_peak")
df_num   <- df[ , num_cols]
# Matriz de correlación (gráfico base)
C <- plot_cor_matrix(df_num)
round(C, 2)
# Matriz de correlación (gráfico base)
C <- plot_cor_matrix(df_num)
# Comprobaciones mínimas
if (!requireNamespace("pROC", quietly = TRUE)) {
stop("Instala 'pROC' para esta sección (está en Imports del paquete).")
}
# Comprobaciones mínimas
if (!requireNamespace("pROC", quietly = TRUE)) {
stop("Instala 'pROC' para esta sección (está en Imports del paquete).")
}
if (!exists("normalize01")) normalize01 <- function(x) (x - min(x)) / (max(x) - min(x))
# Etiqueta binaria: "muy ruidoso" si pico > 100 dB
loud_real <- as.integer(df$db_peak > 100)
# Puntaje 1: BPM solo (re-escalado a [0,1])
score_bpm <- normalize01(df$bpm_mean)
# Puntaje 2: Combinado BPM + Energía (z-score interno + mezcla 60/40) → [0,1]
z <- function(x) (x - mean(x)) / sd(x)
score_mix <- 0.6 * z(df$bpm_mean) + 0.4 * z(df$energy)
score_mix <- normalize01(score_mix)
# Preparamos data.frames para tu función dibujar_roc(A, col_real=1, col_prob=2)
A_bpm <- data.frame(real = loud_real, prob = score_bpm)
A_mix <- data.frame(real = loud_real, prob = score_mix)
# Trazamos y recuperamos el objeto 'roc' (tu función lo devuelve de forma invisible)
par(mfrow = c(1,2), mar = c(4,4,3,1))
ro_bpm <- dibujar_roc(A_bpm) ; title("ROC - Score BPM")
source("plotting.R")
ro_bpm <- dibujar_roc(A_bpm) ; title("ROC - Score BPM")
source("R/plotting.R")
ro_bpm <- dibujar_roc(A_bpm) ; title("ROC - Score BPM")
ro_mix <- dibujar_roc(A_mix) ; title("ROC - Score BPM+Energía")
par(mfrow = c(1,1))
# AUC numérico
auc_bpm <- pROC::auc(ro_bpm)
ro_bpm <- dibujar_roc(A_bpm) ; title("ROC - Score BPM")
ro_mix <- dibujar_roc(A_mix) ; title("ROC - Score BPM+Energía")
par(mfrow = c(1,1))
ro_bpm <- dibujar_roc(A_bpm) ; title("ROC - Score BPM")
par(mfrow = c(1,2), mar = c(4,4,3,1))
ro_bpm <- dibujar_roc(A_bpm, col = "blue")
ro_bpm <- dibujar_roc(A_bpm, col = "blue")
set.seed(123)
real <- c(1, 0, 1, 1, 0, 1)  # respuesta binaria (público)
prob <- runif(6, 0, 1)       # “score” inventado
library(pROC)
roc_obj <- roc(real, prob)
plot(roc_obj, col="blue", lwd=2, main=paste("ROC Mini-Festival (AUC =", round(auc(roc_obj), 2), ")"))
abline(0,1,lty=2,col="red")
# Variable real: 1 = vibró con la banda, 0 = no vibró
real <- rbinom(n, 1, 0.6)
# Score: lo hacemos correlacionado con "real" para que AUC > 0.5
prob <- real * runif(n, 0.4, 1) + (1 - real) * runif(n, 0, 0.6)
# Data.frame para tu función
A_festival <- data.frame(real = real, prob = prob)
# Llamada a tu función definida en plotting.R
source("R/plotting.R")   # asegúrate de que está en la carpeta R/
dibujar_roc(A_festival)
## ---------------------------
## ROC–AUC · Mini-festival
## ---------------------------
n <- 100
# Variable real: 1 = vibró con la banda, 0 = no vibró
real <- rbinom(n, 1, 0.6)
# Score: lo hacemos correlacionado con "real" para que AUC > 0.5
prob <- real * runif(n, 0.4, 1) + (1 - real) * runif(n, 0, 0.6)
# Data.frame para tu función
A_festival <- data.frame(real = real, prob = prob)
# Llamada a tu función definida en plotting.R
source("R/plotting.R")   # asegúrate de que está en la carpeta R/
dibujar_roc(A_festival)
# Creamos variables "inventadas" para cada banda
df_band <- data.frame(
energia = runif(6, 60, 100),
popularidad = runif(6, 40, 95),
bpm = runif(6, 80, 160),
intensidad_luces = runif(6, 50, 100)
)
rownames(df_band) <- bandas
## ---------------------------
## Correlaciones · Mini-festival
## ---------------------------
# Mini-festival con 6 bandas
bandas <- c("The Rockets", "Synth Waves", "Indie Roots",
"Metal Storm", "Jazz Vibes", "Pop Lights")
# Creamos variables "inventadas" para cada banda
df_band <- data.frame(
energia = runif(6, 60, 100),
popularidad = runif(6, 40, 95),
bpm = runif(6, 80, 160),
intensidad_luces = runif(6, 50, 100)
)
rownames(df_band) <- bandas
# --- Tu función de correlaciones ---
library(corrplot)
M_band <- dibujar_correlaciones(df_band)
M_band
# Umbral óptimo (criterio "best" ~ Youden J)
best_mix <- pROC::coords(ro_mix, "best",
ret = c("threshold","sensitivity","specificity","accuracy"))
best_mix
knitr::include_graphics("images/minifestival.jpg")
install.packages("rmarkdown")
install.packages("rmarkdown")
library(rmarkdown)
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
root_path <- "C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r"
if (dir.exists(root_path)) {
knitr::opts_knit$set(root.dir = root_path)
} else {
warning(paste("⚠️ La ruta no existe o no es accesible:", root_path))
}
if (dir.exists(root_path)) {
knitr::opts_knit$set(root.dir = root_path)
} else {
warning(paste("⚠️ La ruta no existe o no es accesible:", root_path))
}
## 1. Resumen y Objetivos
Este documento presenta el paquete permupack, un conjunto de utilidades didácticas que cubre tareas frecuentes del curso: creación y manejo de objetos, discretización y entropía, operaciones con matrices, permutaciones, entrada/salida y registro (logging), visualización de correlaciones, evaluación con curvas ROC, recursividad y clases S4. Nuestro objetivo es ilustrar el uso práctico de cada bloque con ejemplos reproducibles, destacando buenas prácticas, decisiones típicas (p. ej., cuándo discretizar o normalizar) y errores comunes que conviene evitar.
## 2. Materiales y Configuración
Todas las demostraciones se ejecutan con R (versión indicada por sessionInfo()), y dependen únicamente de los paquetes declarados en DESCRIPTION (usados vía pkg::fun desde el propio paquete). Configuramos una semilla para garantizar reproducibilidad, definimos opciones globales de knitr (tamaño de figuras y mensajes) y, cuando procede, generamos datos de ejemplo en memoria para no depender de ficheros externos. Si se usan archivos, estos se localizan mediante system.file() desde inst/extdata del paquete para asegurar portabilidad tras la instalación.
## Carrera de drones
El paquete se organiza en módulos temáticos que separan funcionalidad (ficheros en R/) de documentación (ayuda generada con roxygen2 y viñetas en vignettes/).
### 3.1 Básicos
Estas funciones son la capa de preprocesado más simple sobre la que se apoyan otros bloques (discretización, matrices, correlaciones). Aquí aclaramos cuándo conviene normalizar o estandarizar y cómo estas transformaciones influyen en pasos posteriores.
Imagina que organizamos una carrera de drones en un circuito de 100 km. Para analizar y practicar conceptos estadísticos (normalización, z-scores, correlaciones, etc.), representamos la carrera con una serie de supuestos:
1. El recorrido está dividido en puntos de control cada 2 km (51 posiciones en total).
```{r, echo=FALSE, include=FALSE}
## ---------------------------
## Basics · Carrera de drones
## ---------------------------
set.seed(123)
files <- c("objects", "io", "Permutation", "utils")
lapply(files, function(f) source(paste0("R/", f, ".R")))
# 1) Puntos de control: cada 2 km (0..100)
checkpoints <- seq(0, 100, by = 2)
n          <- length(checkpoints)    # 51
# 2) Estado inicial de baterías (100% en todos los puntos)
battery <- rep(100, n)   # repite 100, n veces
pos_labels <- paste0("Pos", 1:n)
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
library(rmarkdown)
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
library(rmarkdown)
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
knitr::opts_chunk$set(echo = TRUE)
setwd("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r")
library(rmarkdown)
render("C:/Users/usuario/OneDrive - alumni.unav.es/UPV/Software_Matematico_Estadistico/Rstudio/permupack_r/vignettes/Minivignette.Rmd",
output_format = "html_document")
